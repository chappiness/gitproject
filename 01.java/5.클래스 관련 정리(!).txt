1.setter 메소드
필드에 변경할 값을 전달받아서
필드 값을 변경하는  메소드

2.getter 메소드
필드에 기록된 값을 읽어서
요청한쪽으로 읽은 값을 넘기는 메소드

3.오버로딩
함수의 매개변수의 타입이나 갯수를 달리하여 같은 이름의 함수 중복해서 정의

4.오버라이딩
상속받은 클라스가 함수를 재정의 하는 것

5.상속받을떄는 클래스명 extends 부모 클래스를 적어주면 된다.
상속을 하면 노력과 시간 낭비를 줄일 수있다.
또한 각기 다른 변수선언을 똑같이 만들수 있다.

6.S 클래스가 A,B,C 하위 클래스를 갖고 있다면 new를 사용했을시에
 A a=new A>>>>>S a=new A 가능 
 B a=new B>>>>>S a=new B	 가능 다만 B에 있는 메소드를 출력할때는 명시적 변환을 (하위클래스) 해야 한다.
 C a=new C>>>>>S a=new C	가능

7.this. : 내 객체의 vs this() :한 클래스의 생성자 함수

8.super. 부모클래스의 매소드를 가져올때 쓴다 vs super() 수퍼 클래스의 생성자

1.부모클래스,아들클래스,아들클래스 메인 함수있다고 하자
부모클래스엔 new a,메서드1,메서드2
아들클래스엔 new b,메서드1, 메서드 2가 출력가능,추가적으로 메서드 3 만든다
부모한테 받은 메서드 2는 마음에 아들어서 수정한다고 하면
메서드 2를 override를 한다.(이떄 바꾼 메서드 2는 부모 클래스 객체가 사용못함)
그리고 아들클래스 생성자함수에서 부모의 메서드를 가져오고 싶을때
super.를 이용한다.

부모 클래스에 생성자함수(),생성자함수(매개변수)
아들 클래스에도 생성자함수(),생성자함수(매개변수)
아들 클래스메인에서 아들 클래스의 생성자함수를 불러오면
자연스레 부모 클래스에 있는 생성자함수를 거쳐서 나온다

그래서 예를들어서 부모 클래스에 생성자함수()를 없애면
아들 클래스에 생성자함수()는 실행이 되지 않는다.마찬가지로
아들 클래스에 생성자함수(매개변수)는 실행이 되지 않는다.
부모클래스 생성자 함수()     1번//아들클래스 생성자 함수() 2번//
//실행순서
부모클래스 생성자 함수()     1번// 아들클래스 생성자 함수() //
부모클래스 생성자 함수(매개변수)2번  아들클래스 생성자 함수(매개변수) 3번
//super() 
생성자 없는 부모클래스  >>  생성자 있는 아들클래스
생성자 없는 부모클래스        생성자 있는 아들클래스(super() 앞이면) 
객체 뽑아서 출력하면 생성자 없는 부모클래스에서 바로 옴